import { stringToIdentifier } from "../server/init_safe_deps.ts";
import { extname, join, normalize } from "./deps.ts";

/**
 * Import specifiers must have forward slashes
 */
function toImportSpecifier(file: string) {
  let specifier = normalize(file).replace(/\\/g, "/");
  if (!specifier.startsWith(".")) {
    specifier = "./" + specifier;
  }
  return specifier;
}

// Create a valid JS identifier out of the project relative specifier.
// Note that we only need to deal with strings that _must_ have been
// valid file names in Windows, macOS and Linux and every identifier we
// create here will be prefixed with at least one "$". This greatly
// simplifies the invalid characters we have to account for.
export function specifierToIdentifier(specifier: string, used: Set<string>) {
  specifier = specifier.replace(/^(?:\.\/routes|\.\/islands)\//, "");
  const ext = extname(specifier);
  if (ext) specifier = specifier.slice(0, -ext.length);

  // Turn the specifier into a readable JS identifier
  let ident = stringToIdentifier(specifier);

  if (used.has(ident)) {
    let check = ident;
    let i = 1;
    while (used.has(check)) {
      check = `${ident}_${i++}`;
    }
    ident = check;
  }

  used.add(ident);
  return ident;
}

export interface Manifest {
  routes: string[];
  islands: string[];
}

export async function generate(directory: string, manifest: Manifest) {
  const { routes, islands } = manifest;

  // Keep track of which identifier we've already used
  const used = new Set<string>();

  const normalizedRoutes = new Map<string, string>();
  for (let i = 0; i < routes.length; i++) {
    const file = routes[i];
    const specifier = toImportSpecifier(file);
    const identifier = specifierToIdentifier(specifier, used);
    normalizedRoutes.set(specifier, identifier);
  }

  const normalizedIslands: { specifier: string; identifier: string }[] = [];
  for (let i = 0; i < islands.length; i++) {
    const file = islands[i];
    const specifier = toImportSpecifier(file);
    const identifier = specifierToIdentifier(specifier, used);
    normalizedIslands.push({ specifier, identifier });
  }

  const output = `// DO NOT EDIT. This file is generated by Fresh.
// This file SHOULD be checked into source version control.
// This file is automatically updated during development when running \`dev.ts\`.

${
    Array.from(normalizedRoutes.entries()).map(([specifier, identifier]) =>
      `import * as $${identifier} from "${specifier}";`
    ).join(
      "\n",
    )
  }
${
    normalizedIslands.map(({ specifier, identifier }) =>
      `import * as $${identifier} from "${specifier}";`
    )
      .join("\n")
  }
import type { Manifest } from "$fresh/server.ts";

const manifest = {
  routes: {
    ${
    Array.from(normalizedRoutes.entries()).map(([specifier, identifier]) =>
      `${JSON.stringify(`${specifier}`)}: $${identifier},`
    )
      .join("\n    ")
  }
  },
  islands: {
    ${
    normalizedIslands.map(({ specifier, identifier }) =>
      `${JSON.stringify(`${specifier}`)}: $${identifier},`
    )
      .join("\n    ")
  }
  },
  baseUrl: import.meta.url,
} satisfies Manifest;

export default manifest;
`;

  const proc = new Deno.Command(Deno.execPath(), {
    args: ["fmt", "-"],
    stdin: "piped",
    stdout: "piped",
    stderr: "null",
  }).spawn();

  const raw = new ReadableStream({
    start(controller) {
      controller.enqueue(new TextEncoder().encode(output));
      controller.close();
    },
  });
  await raw.pipeTo(proc.stdin);
  const { stdout } = await proc.output();

  const manifestStr = new TextDecoder().decode(stdout);
  const manifestPath = join(directory, "./fresh.gen.ts");

  await Deno.writeTextFile(manifestPath, manifestStr);
  console.log(
    `%cThe manifest has been generated for ${routes.length} routes and ${islands.length} islands.`,
    "color: blue; font-weight: bold",
  );
}

// denoCacheMetadata={"headers":{"content-type":"application/typescript; charset=utf-8","access-control-allow-origin":"*","server":"deno/gcp-asia-southeast1","strict-transport-security":"max-age=63072000; includeSubDomains; preload","accept-ranges":"bytes","x-amz-server-side-encryption":"AES256","cross-origin-embedder-policy":"same-origin","x-amz-version-id":"PHn1aqpWucWQP63rChoO2j3lv0BMP2fm","cross-origin-opener-policy":"same-origin","server-timing":"fetchSource;dur=34","content-length":"3882","x-amz-cf-pop":"SIN52-P1","x-frame-options":"DENY","cross-origin-resource-policy":"same-origin","cache-control":"public, max-age=31536000, immutable","vary":"Accept-Encoding, Origin","age":"21768801","content-security-policy":"default-src 'none'; style-src 'unsafe-inline'; sandbox","etag":"\"a2ec31243802ad149f6becba7214a301\"","date":"Thu, 17 Oct 2024 14:04:08 GMT","via":"http/2 edgeproxy-h","x-amz-cf-id":"qAx5e00scCJoMdOwfslY6JT54h6FE-DSA0hE2xjaXux7ajzFG0tGbw==","referrer-policy":"strict-origin-when-cross-origin","x-amz-replication-status":"COMPLETED","x-content-type-options":"nosniff","last-modified":"Mon, 14 Oct 2024 12:51:13 GMT","x-cache":"Hit from cloudfront"},"url":"https://deno.land/x/fresh@1.7.3/src/dev/manifest.ts","time":1750942649}