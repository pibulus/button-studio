import { stringToIdentifier } from "../server/init_safe_deps.ts";
import { extname, join, normalize } from "./deps.ts";
/**
 * Import specifiers must have forward slashes
 */ function toImportSpecifier(file) {
  let specifier = normalize(file).replace(/\\/g, "/");
  if (!specifier.startsWith(".")) {
    specifier = "./" + specifier;
  }
  return specifier;
}
// Create a valid JS identifier out of the project relative specifier.
// Note that we only need to deal with strings that _must_ have been
// valid file names in Windows, macOS and Linux and every identifier we
// create here will be prefixed with at least one "$". This greatly
// simplifies the invalid characters we have to account for.
export function specifierToIdentifier(specifier, used) {
  specifier = specifier.replace(/^(?:\.\/routes|\.\/islands)\//, "");
  const ext = extname(specifier);
  if (ext) specifier = specifier.slice(0, -ext.length);
  // Turn the specifier into a readable JS identifier
  let ident = stringToIdentifier(specifier);
  if (used.has(ident)) {
    let check = ident;
    let i = 1;
    while(used.has(check)){
      check = `${ident}_${i++}`;
    }
    ident = check;
  }
  used.add(ident);
  return ident;
}
export async function generate(directory, manifest) {
  const { routes, islands } = manifest;
  // Keep track of which identifier we've already used
  const used = new Set();
  const normalizedRoutes = new Map();
  for(let i = 0; i < routes.length; i++){
    const file = routes[i];
    const specifier = toImportSpecifier(file);
    const identifier = specifierToIdentifier(specifier, used);
    normalizedRoutes.set(specifier, identifier);
  }
  const normalizedIslands = [];
  for(let i = 0; i < islands.length; i++){
    const file = islands[i];
    const specifier = toImportSpecifier(file);
    const identifier = specifierToIdentifier(specifier, used);
    normalizedIslands.push({
      specifier,
      identifier
    });
  }
  const output = `// DO NOT EDIT. This file is generated by Fresh.
// This file SHOULD be checked into source version control.
// This file is automatically updated during development when running \`dev.ts\`.

${Array.from(normalizedRoutes.entries()).map(([specifier, identifier])=>`import * as $${identifier} from "${specifier}";`).join("\n")}
${normalizedIslands.map(({ specifier, identifier })=>`import * as $${identifier} from "${specifier}";`).join("\n")}
import type { Manifest } from "$fresh/server.ts";

const manifest = {
  routes: {
    ${Array.from(normalizedRoutes.entries()).map(([specifier, identifier])=>`${JSON.stringify(`${specifier}`)}: $${identifier},`).join("\n    ")}
  },
  islands: {
    ${normalizedIslands.map(({ specifier, identifier })=>`${JSON.stringify(`${specifier}`)}: $${identifier},`).join("\n    ")}
  },
  baseUrl: import.meta.url,
} satisfies Manifest;

export default manifest;
`;
  const proc = new Deno.Command(Deno.execPath(), {
    args: [
      "fmt",
      "-"
    ],
    stdin: "piped",
    stdout: "piped",
    stderr: "null"
  }).spawn();
  const raw = new ReadableStream({
    start (controller) {
      controller.enqueue(new TextEncoder().encode(output));
      controller.close();
    }
  });
  await raw.pipeTo(proc.stdin);
  const { stdout } = await proc.output();
  const manifestStr = new TextDecoder().decode(stdout);
  const manifestPath = join(directory, "./fresh.gen.ts");
  await Deno.writeTextFile(manifestPath, manifestStr);
  console.log(`%cThe manifest has been generated for ${routes.length} routes and ${islands.length} islands.`, "color: blue; font-weight: bold");
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vZGVuby5sYW5kL3gvZnJlc2hAMS43LjMvc3JjL2Rldi9tYW5pZmVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHJpbmdUb0lkZW50aWZpZXIgfSBmcm9tIFwiLi4vc2VydmVyL2luaXRfc2FmZV9kZXBzLnRzXCI7XG5pbXBvcnQgeyBleHRuYW1lLCBqb2luLCBub3JtYWxpemUgfSBmcm9tIFwiLi9kZXBzLnRzXCI7XG5cbi8qKlxuICogSW1wb3J0IHNwZWNpZmllcnMgbXVzdCBoYXZlIGZvcndhcmQgc2xhc2hlc1xuICovXG5mdW5jdGlvbiB0b0ltcG9ydFNwZWNpZmllcihmaWxlOiBzdHJpbmcpIHtcbiAgbGV0IHNwZWNpZmllciA9IG5vcm1hbGl6ZShmaWxlKS5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTtcbiAgaWYgKCFzcGVjaWZpZXIuc3RhcnRzV2l0aChcIi5cIikpIHtcbiAgICBzcGVjaWZpZXIgPSBcIi4vXCIgKyBzcGVjaWZpZXI7XG4gIH1cbiAgcmV0dXJuIHNwZWNpZmllcjtcbn1cblxuLy8gQ3JlYXRlIGEgdmFsaWQgSlMgaWRlbnRpZmllciBvdXQgb2YgdGhlIHByb2plY3QgcmVsYXRpdmUgc3BlY2lmaWVyLlxuLy8gTm90ZSB0aGF0IHdlIG9ubHkgbmVlZCB0byBkZWFsIHdpdGggc3RyaW5ncyB0aGF0IF9tdXN0XyBoYXZlIGJlZW5cbi8vIHZhbGlkIGZpbGUgbmFtZXMgaW4gV2luZG93cywgbWFjT1MgYW5kIExpbnV4IGFuZCBldmVyeSBpZGVudGlmaWVyIHdlXG4vLyBjcmVhdGUgaGVyZSB3aWxsIGJlIHByZWZpeGVkIHdpdGggYXQgbGVhc3Qgb25lIFwiJFwiLiBUaGlzIGdyZWF0bHlcbi8vIHNpbXBsaWZpZXMgdGhlIGludmFsaWQgY2hhcmFjdGVycyB3ZSBoYXZlIHRvIGFjY291bnQgZm9yLlxuZXhwb3J0IGZ1bmN0aW9uIHNwZWNpZmllclRvSWRlbnRpZmllcihzcGVjaWZpZXI6IHN0cmluZywgdXNlZDogU2V0PHN0cmluZz4pIHtcbiAgc3BlY2lmaWVyID0gc3BlY2lmaWVyLnJlcGxhY2UoL14oPzpcXC5cXC9yb3V0ZXN8XFwuXFwvaXNsYW5kcylcXC8vLCBcIlwiKTtcbiAgY29uc3QgZXh0ID0gZXh0bmFtZShzcGVjaWZpZXIpO1xuICBpZiAoZXh0KSBzcGVjaWZpZXIgPSBzcGVjaWZpZXIuc2xpY2UoMCwgLWV4dC5sZW5ndGgpO1xuXG4gIC8vIFR1cm4gdGhlIHNwZWNpZmllciBpbnRvIGEgcmVhZGFibGUgSlMgaWRlbnRpZmllclxuICBsZXQgaWRlbnQgPSBzdHJpbmdUb0lkZW50aWZpZXIoc3BlY2lmaWVyKTtcblxuICBpZiAodXNlZC5oYXMoaWRlbnQpKSB7XG4gICAgbGV0IGNoZWNrID0gaWRlbnQ7XG4gICAgbGV0IGkgPSAxO1xuICAgIHdoaWxlICh1c2VkLmhhcyhjaGVjaykpIHtcbiAgICAgIGNoZWNrID0gYCR7aWRlbnR9XyR7aSsrfWA7XG4gICAgfVxuICAgIGlkZW50ID0gY2hlY2s7XG4gIH1cblxuICB1c2VkLmFkZChpZGVudCk7XG4gIHJldHVybiBpZGVudDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNYW5pZmVzdCB7XG4gIHJvdXRlczogc3RyaW5nW107XG4gIGlzbGFuZHM6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGUoZGlyZWN0b3J5OiBzdHJpbmcsIG1hbmlmZXN0OiBNYW5pZmVzdCkge1xuICBjb25zdCB7IHJvdXRlcywgaXNsYW5kcyB9ID0gbWFuaWZlc3Q7XG5cbiAgLy8gS2VlcCB0cmFjayBvZiB3aGljaCBpZGVudGlmaWVyIHdlJ3ZlIGFscmVhZHkgdXNlZFxuICBjb25zdCB1c2VkID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgY29uc3Qgbm9ybWFsaXplZFJvdXRlcyA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZmlsZSA9IHJvdXRlc1tpXTtcbiAgICBjb25zdCBzcGVjaWZpZXIgPSB0b0ltcG9ydFNwZWNpZmllcihmaWxlKTtcbiAgICBjb25zdCBpZGVudGlmaWVyID0gc3BlY2lmaWVyVG9JZGVudGlmaWVyKHNwZWNpZmllciwgdXNlZCk7XG4gICAgbm9ybWFsaXplZFJvdXRlcy5zZXQoc3BlY2lmaWVyLCBpZGVudGlmaWVyKTtcbiAgfVxuXG4gIGNvbnN0IG5vcm1hbGl6ZWRJc2xhbmRzOiB7IHNwZWNpZmllcjogc3RyaW5nOyBpZGVudGlmaWVyOiBzdHJpbmcgfVtdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaXNsYW5kcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGZpbGUgPSBpc2xhbmRzW2ldO1xuICAgIGNvbnN0IHNwZWNpZmllciA9IHRvSW1wb3J0U3BlY2lmaWVyKGZpbGUpO1xuICAgIGNvbnN0IGlkZW50aWZpZXIgPSBzcGVjaWZpZXJUb0lkZW50aWZpZXIoc3BlY2lmaWVyLCB1c2VkKTtcbiAgICBub3JtYWxpemVkSXNsYW5kcy5wdXNoKHsgc3BlY2lmaWVyLCBpZGVudGlmaWVyIH0pO1xuICB9XG5cbiAgY29uc3Qgb3V0cHV0ID0gYC8vIERPIE5PVCBFRElULiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IEZyZXNoLlxuLy8gVGhpcyBmaWxlIFNIT1VMRCBiZSBjaGVja2VkIGludG8gc291cmNlIHZlcnNpb24gY29udHJvbC5cbi8vIFRoaXMgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgZHVyaW5nIGRldmVsb3BtZW50IHdoZW4gcnVubmluZyBcXGBkZXYudHNcXGAuXG5cbiR7XG4gICAgQXJyYXkuZnJvbShub3JtYWxpemVkUm91dGVzLmVudHJpZXMoKSkubWFwKChbc3BlY2lmaWVyLCBpZGVudGlmaWVyXSkgPT5cbiAgICAgIGBpbXBvcnQgKiBhcyAkJHtpZGVudGlmaWVyfSBmcm9tIFwiJHtzcGVjaWZpZXJ9XCI7YFxuICAgICkuam9pbihcbiAgICAgIFwiXFxuXCIsXG4gICAgKVxuICB9XG4ke1xuICAgIG5vcm1hbGl6ZWRJc2xhbmRzLm1hcCgoeyBzcGVjaWZpZXIsIGlkZW50aWZpZXIgfSkgPT5cbiAgICAgIGBpbXBvcnQgKiBhcyAkJHtpZGVudGlmaWVyfSBmcm9tIFwiJHtzcGVjaWZpZXJ9XCI7YFxuICAgIClcbiAgICAgIC5qb2luKFwiXFxuXCIpXG4gIH1cbmltcG9ydCB0eXBlIHsgTWFuaWZlc3QgfSBmcm9tIFwiJGZyZXNoL3NlcnZlci50c1wiO1xuXG5jb25zdCBtYW5pZmVzdCA9IHtcbiAgcm91dGVzOiB7XG4gICAgJHtcbiAgICBBcnJheS5mcm9tKG5vcm1hbGl6ZWRSb3V0ZXMuZW50cmllcygpKS5tYXAoKFtzcGVjaWZpZXIsIGlkZW50aWZpZXJdKSA9PlxuICAgICAgYCR7SlNPTi5zdHJpbmdpZnkoYCR7c3BlY2lmaWVyfWApfTogJCR7aWRlbnRpZmllcn0sYFxuICAgIClcbiAgICAgIC5qb2luKFwiXFxuICAgIFwiKVxuICB9XG4gIH0sXG4gIGlzbGFuZHM6IHtcbiAgICAke1xuICAgIG5vcm1hbGl6ZWRJc2xhbmRzLm1hcCgoeyBzcGVjaWZpZXIsIGlkZW50aWZpZXIgfSkgPT5cbiAgICAgIGAke0pTT04uc3RyaW5naWZ5KGAke3NwZWNpZmllcn1gKX06ICQke2lkZW50aWZpZXJ9LGBcbiAgICApXG4gICAgICAuam9pbihcIlxcbiAgICBcIilcbiAgfVxuICB9LFxuICBiYXNlVXJsOiBpbXBvcnQubWV0YS51cmwsXG59IHNhdGlzZmllcyBNYW5pZmVzdDtcblxuZXhwb3J0IGRlZmF1bHQgbWFuaWZlc3Q7XG5gO1xuXG4gIGNvbnN0IHByb2MgPSBuZXcgRGVuby5Db21tYW5kKERlbm8uZXhlY1BhdGgoKSwge1xuICAgIGFyZ3M6IFtcImZtdFwiLCBcIi1cIl0sXG4gICAgc3RkaW46IFwicGlwZWRcIixcbiAgICBzdGRvdXQ6IFwicGlwZWRcIixcbiAgICBzdGRlcnI6IFwibnVsbFwiLFxuICB9KS5zcGF3bigpO1xuXG4gIGNvbnN0IHJhdyA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShvdXRwdXQpKTtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9LFxuICB9KTtcbiAgYXdhaXQgcmF3LnBpcGVUbyhwcm9jLnN0ZGluKTtcbiAgY29uc3QgeyBzdGRvdXQgfSA9IGF3YWl0IHByb2Mub3V0cHV0KCk7XG5cbiAgY29uc3QgbWFuaWZlc3RTdHIgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoc3Rkb3V0KTtcbiAgY29uc3QgbWFuaWZlc3RQYXRoID0gam9pbihkaXJlY3RvcnksIFwiLi9mcmVzaC5nZW4udHNcIik7XG5cbiAgYXdhaXQgRGVuby53cml0ZVRleHRGaWxlKG1hbmlmZXN0UGF0aCwgbWFuaWZlc3RTdHIpO1xuICBjb25zb2xlLmxvZyhcbiAgICBgJWNUaGUgbWFuaWZlc3QgaGFzIGJlZW4gZ2VuZXJhdGVkIGZvciAke3JvdXRlcy5sZW5ndGh9IHJvdXRlcyBhbmQgJHtpc2xhbmRzLmxlbmd0aH0gaXNsYW5kcy5gLFxuICAgIFwiY29sb3I6IGJsdWU7IGZvbnQtd2VpZ2h0OiBib2xkXCIsXG4gICk7XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUyxrQkFBa0IsUUFBUSw4QkFBOEI7QUFDakUsU0FBUyxPQUFPLEVBQUUsSUFBSSxFQUFFLFNBQVMsUUFBUSxZQUFZO0FBRXJEOztDQUVDLEdBQ0QsU0FBUyxrQkFBa0IsSUFBWTtFQUNyQyxJQUFJLFlBQVksVUFBVSxNQUFNLE9BQU8sQ0FBQyxPQUFPO0VBQy9DLElBQUksQ0FBQyxVQUFVLFVBQVUsQ0FBQyxNQUFNO0lBQzlCLFlBQVksT0FBTztFQUNyQjtFQUNBLE9BQU87QUFDVDtBQUVBLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsdUVBQXVFO0FBQ3ZFLG1FQUFtRTtBQUNuRSw0REFBNEQ7QUFDNUQsT0FBTyxTQUFTLHNC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
// denoCacheMetadata=17842006350607249867,4966341678342062101